<!doctype html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Fake AR — 3D Reticle (Ring) + car.glb</title>

<!-- three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/examples/js/loaders/GLTFLoader.js"></script>

<style>
  html,body { height:100%; margin:0; background:#000; font-family:Arial, sans-serif; -webkit-user-select:none; user-select:none; overflow:hidden; }
  #video { position:fixed; inset:0; width:100%; height:100%; object-fit:cover; z-index:0; } /* الكاميرا كخلفية */
  #three { position:fixed; inset:0; z-index:1; touch-action:none; }
  #hud {
    position:fixed; z-index:3; left:12px; top:12px; color:#fff; background:rgba(0,0,0,0.45);
    padding:8px 10px; border-radius:8px; font-size:14px;
  }
  #hint { position:fixed; right:12px; top:12px; z-index:3; color:#fff; background:rgba(0,0,0,0.45);
    padding:8px 10px; border-radius:8px; font-size:13px; }
</style>
</head>
<body>

<video id="video" autoplay playsinline muted></video>
<div id="three"></div>
<div id="hud">اضغط منتصف الشاشة (أو اضغط المكان المخصص) لوضع الموديل</div>
<div id="hint">Pinch للتكبير • إصبع واحد للسحب • إصبعان للتدوير</div>

<script>
(async ()=>{

/* ===========================
   1) تشغيل الكاميرا الخلفية
   =========================== */
const video = document.getElementById('video');
async function startCamera(){
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: "environment" } }, audio: false
    });
    video.srcObject = stream;
    await video.play();
  } catch(err){
    alert('تعذر فتح الكاميرا: ' + (err.message || err));
    console.error(err);
  }
}
await startCamera();

/* ===========================
   2) إعداد Three.js
   =========================== */
const container = document.getElementById('three');
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = null;

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 1000);
camera.position.set(0,0,0.05);

// ضوء
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(0.5, 1, 0.3);
scene.add(dir);

/* ===========================
   3) Reticle (حلقة 3D) — ring
   =========================== */
const reticle = new THREE.Mesh(
  new THREE.TorusGeometry(0.15, 0.01, 16, 64),
  new THREE.MeshStandardMaterial({ color: 0x00c8ff, emissive: 0x00aacc, metalness:0.1, roughness:0.6, transparent:true, opacity:0.95 })
);
reticle.rotation.x = -Math.PI/2; // افتراضياً موازٍ للـ XZ (كحلقة على الأرض)
scene.add(reticle);

// نبدأ reticle غير مرئي حتى نعرضه بعد جاهزية الفيديو/المشهد
reticle.visible = true;

/* ===========================
   4) جذع الموديل + ظل
   =========================== */
const modelRoot = new THREE.Group();
modelRoot.visible = false;
scene.add(modelRoot);

// ظل بسيط (مستوى مع شفافية)
const shadow = new THREE.Mesh(
  new THREE.PlaneGeometry(1.4,1.4),
  new THREE.MeshBasicMaterial({ color:0x000000, opacity:0.25, transparent:true })
);
shadow.rotation.x = -Math.PI/2;
shadow.position.y = 0.001;
shadow.visible = false;
modelRoot.add(shadow);

/* ===========================
   5) تحميل car.glb أو fallback
   =========================== */
const loader = new THREE.GLTFLoader();
let modelLoaded = false;
try {
  const gltf = await new Promise((res, rej) => {
    loader.load('car.glb', res, null, err => rej(err));
  });
  const root = gltf.scene || gltf.scenes[0];
  // ضبط مقياس ابتدائي مناسب (تعدل لاحقاً)
  root.scale.set(0.6,0.6,0.6);
  root.traverse(n => { if(n.isMesh){ n.castShadow = true; n.receiveShadow = true; }});
  modelRoot.add(root);
  modelLoaded = true;
  console.log('car.glb loaded');
} catch(e){
  console.warn('لم يتم تحميل car.glb — سيظهر مكعب افتراضي', e);
  const box = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.4,1.2), new THREE.MeshStandardMaterial({ color:0x2194ce }));
  box.position.y = 0.2;
  modelRoot.add(box);
}

/* ===========================
   6) تحويل نقطة شاشة -> موضع في العالم بعمق ثابت
   =========================== */
const planeDistance = 2.0; // المسافة الافتراضية أمام الكاميرا بالأمتار
function screenCenterWorld(offsetX = 0, offsetY = 0){
  // center of screen offset by tilt offsets in pixels
  const cx = (window.innerWidth/2) + offsetX;
  const cy = (window.innerHeight/2) + offsetY;
  const nx = (cx / window.innerWidth) * 2 - 1;
  const ny = - (cy / window.innerHeight) * 2 + 1;
  const ndc = new THREE.Vector3(nx, ny, 0.5);
  ndc.unproject(camera);
  const dir = ndc.sub(camera.position).normalize();
  return camera.position.clone().add(dir.multiplyScalar(planeDistance));
}

/* ===========================
   7) تمرير بيانات الميل (tilt) لتحريك reticle خفيف
   =========================== */
let tiltOffsetX = 0; // pixels
let tiltOffsetY = 0;
let lastBeta = 90, lastGamma = 0;

function handleDeviceOrientation(ev){
  // ev.beta: tilt front/back (0..180), ev.gamma: left/right (-90..90)
  if (ev.beta === null || ev.gamma === null) return;
  lastBeta = ev.beta;
  lastGamma = ev.gamma;
  // نحول الميل إلى إزاحات شاشة صغيرة (مقاسات قابلة للتعديل)
  const maxOffset = Math.min(window.innerWidth, window.innerHeight) * 0.18; // أقصى تحرك ~18% من الشاشة
  tiltOffsetX = (ev.gamma / 90) * (maxOffset * 0.35); // يمين/يسار أخف
  tiltOffsetY = ((ev.beta - 90) / 90) * (maxOffset * 0.35); // أمام/خلف أخف
  // عندما الهاتف متجه للأسفل (beta كبيرة) نجعل reticle أكثر مسطحاً
  const flatFactor = Math.min(Math.max((ev.beta - 40) / 50, 0), 1); // 0..1
  // نحول دوران الحلقة لتبدو مسطحة أكثر عند flatFactor=1
  reticle.rotation.x = -Math.PI/2 * (0.5 + 0.5 * flatFactor); // يتغير بين -90deg و -90deg* bigger flatten
  reticle.scale.setScalar(1 + flatFactor*0.15);
}

/* اطلب إذن الحركة على iOS إن لزم */
if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
  // لن نطلب تلقائياً؛ المستخدم سيعمل بتوجيه إذا ظهر زر لاحقًا. لكن نضيف مستمع إن وُجد
  // يمكنك إضافة زر لطلب الإذن إذا تريد تجربة iOS.
}
window.addEventListener('deviceorientation', handleDeviceOrientation, true);

/* ===========================
   8) وضع reticle استناداً للشاشة + الميل
   =========================== */
function updateReticle(){
  const world = screenCenterWorld(tiltOffsetX, tiltOffsetY);
  reticle.position.copy(world);
  // اجعل الحلقة دائمًا تواجه الكاميرا قليلاً (اختياري)
  const toCamera = camera.position.clone().sub(reticle.position).normalize();
  // ثابت تقليدي: حلقة على الأرض (XZ) لكن يمكن جعلها تميل للخلف قليلاً
  // reticle.lookAt(camera.position); // لا نستخدمه حتى تبقى مسطحة على الأرض
}

/* ===========================
   9) اللمس لوضع الموديل (tap anywhere) — هنا نضعه عند مركز الشاشة (reticle)
   =========================== */
let placed = false;
function placeModelAtReticle(){
  if (!reticle.visible) return;
  modelRoot.position.copy(reticle.position);
  // ابقِ قاعدة النموذج عند y=0 (تعديل بحسب bounding box)
  const box = new THREE.Box3().setFromObject(modelRoot);
  const minY = box.min.y;
  modelRoot.position.y -= minY; // اجعل القاعدة عند y=0
  modelRoot.visible = true;
  shadow.visible = true;
  placed = true;
  document.getElementById('hud').innerText = 'تم وضع الموديل — يمكنك التكبير/التصغير والسحب والتدوير';
}

// تفعيل اللمس: نستخدم نقرة في منتصف الشاشة أو أي مكان
// نربط حدث pointerdown على كامل اللوحة
renderer.domElement.addEventListener('pointerdown', (ev)=>{
  // إذا المستخدم ضغط بإصبعين (pinch start) لا نضع الموديل
  if (ongoing.pointers.size > 0 && ongoing.pointers.size !== 0) {
    // سيتم التعامل في منطق الإيماءات
  } else {
    // نفعل وضع عندما يكون مكان اللمس قريب من منتصف الشاشة (اختياري)
    // هنا نترجم أنه أي نقرة تضع الموديل في مركز reticle
    placeModelAtReticle();
  }
});

/* ===========================
   10) Gestures: pinch scale, two-finger rotate, one-finger drag (translate)
   =========================== */
const ongoing = { pointers: new Map(), initialDistance:0, initialScale:1, initialAngle:0, lastPan:null };

function getDistance(p1,p2){
  const dx = p2.clientX - p1.clientX; const dy = p2.clientY - p1.clientY;
  return Math.hypot(dx,dy);
}
function getAngle(p1,p2){
  return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX);
}

renderer.domElement.addEventListener('pointerdown', (e)=>{
  renderer.domElement.setPointerCapture(e.pointerId);
  ongoing.pointers.set(e.pointerId, e);
  if (ongoing.pointers.size === 2){
    const pts = Array.from(ongoing.pointers.values());
    ongoing.initialDistance = getDistance(pts[0], pts[1]);
    ongoing.initialAngle = getAngle(pts[0], pts[1]);
    ongoing.initialScale = modelRoot.scale.x || 1;
  } else if (ongoing.pointers.size === 1){
    ongoing.lastPan = { x: e.clientX, y: e.clientY };
  }
});

renderer.domElement.addEventListener('pointermove', (e)=>{
  if (!ongoing.pointers.has(e.pointerId)) return;
  ongoing.pointers.set(e.pointerId, e);

  if (ongoing.pointers.size === 2 && placed){
    const pts = Array.from(ongoing.pointers.values());
    const curDist = getDistance(pts[0], pts[1]);
    const curAngle = getAngle(pts[0], pts[1]);

    // scale
    const scaleFactor = (curDist / ongoing.initialDistance) * ongoing.initialScale;
    modelRoot.scale.setScalar(scaleFactor);

    // rotate (delta angle)
    const delta = curAngle - ongoing.initialAngle;
    modelRoot.rotation.y += delta;
    ongoing.initialAngle = curAngle; // continuous rotation
  } else if (ongoing.pointers.size === 1 && placed){
    // pan: نحرك الموديل بشكل خفيف على مستوى الشاشة (محاكاة لتحريكه على الأرض)
    const p = Array.from(ongoing.pointers.values())[0];
    const dx = p.clientX - ongoing.lastPan.x;
    const dy = p.clientY - ongoing.lastPan.y;
    ongoing.lastPan.x = p.clientX; ongoing.lastPan.y = p.clientY;

    // حساب متجهات right وup في العالم
    const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
    const camRight = new THREE.Vector3().crossVectors(camera.up, camDir).normalize();
    const camUp = camera.up.clone().normalize();

    const factor = 0.0015 * planeDistance;
    modelRoot.position.addScaledVector(camRight, -dx * factor);
    modelRoot.position.addScaledVector(camUp, dy * factor * 0.7);
  }
});

renderer.domElement.addEventListener('pointerup', (e)=>{
  try { renderer.domElement.releasePointerCapture(e.pointerId); } catch(err){}
  ongoing.pointers.delete(e.pointerId);
  ongoing.lastPan = null;
});
renderer.domElement.addEventListener('pointercancel', (e)=>{ ongoing.pointers.delete(e.pointerId); ongoing.lastPan = null; });

/* ===========================
   11) حلقة العرض (render) و تحديثات reticle
   =========================== */
function animate(){
  requestAnimationFrame(animate);
  updateReticle();
  renderer.render(scene, camera);
}
animate();

/* ===========================
   12) ضبط الحجم
   =========================== */
window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});

/* ===========================
   13) رسالة حالة بسيطة
   =========================== */
document.getElementById('hud').innerText = 'اضغط الشاشة لوضع الموديل. حرّك الجهاز لتغيير وضع الحلقة.' + (modelLoaded ? '' : ' (يعمل بموديل افتراضي لأن car.glb لم يُحمّل)');

})(); // end async
</script>

</body>
</html>
